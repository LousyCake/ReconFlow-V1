import { v } from "convex/values";
import { action, internalMutation, internalQuery } from "./_generated/server";
import { internal } from "./_generated/api";

// Helper to fetch subdomains from SecurityTrails
export const fetchSubdomainsFromSecurityTrails = async (domain: string, apiKey: string) => {
  const response = await fetch(
    `https://api.securitytrails.com/v1/domain/${domain}/subdomains`,
    {
      headers: {
        "Content-Type": "application/json",
        "X-Api-Key": apiKey,
      },
    }
  );
  const data = await response.json();
  return (data.subdomains as string[]).map((s) => `${s}.${domain}`);
};

// Helper to fetch IP and ports from Shodan
export const fetchShodanData = async (sub: string, apiKey: string) => {
  const response = await fetch(
    `https://api.shodan.io/shodan/host/${sub}?key=${apiKey}`,
    {
      headers: {
        "Content-Type": "application/json",
      },
    }
  );
  const data = await response.json();
  return data;
};

// Helper to check HTTP exposures
export const checkHttpExposures = async (subdomain: string, path: string, apiKey: string, proto: string, controller: any) => {
  const res = await fetch(`${proto}${subdomain}${path}`, {
    method: "HEAD",
    signal: controller.signal,
  });
  if (res.status === 200) {
    return {
      path,
      status: 200,
      risk: "High",
    };
  }
  return null;
};

export const createScan = internalMutation({
  args: {
    domain: v.string(),
    securityTrailsKey: v.optional(v.string()),
    shodanKey: v.optional(v.string()),
    scanId: v.id("scans"),
  },
  handler: async (ctx, args) => {
    // ...
    const scanId = await ctx.db.insert("scans", {
      domain: args.domain,
      status: "pending",
      // userId is missing here
    });
    // ...
    await ctx.runMutation(internal.recon.completeScan, {
      scanId,
      riskScore: overallRisk,
      subdomainCount: limitedSubdomains.length,
      highRiskCount,
      mediumRiskCount,
      lowRiskCount,
    });
  }
});

export const getRecentScans = query({
  args: {},
  handler: async (ctx) => {
    return await ctx.db.query("scans").order("desc").take(5);
  },
});

export const updateScanStatus = internalMutation({
  args: {
    scanId: v.number(),
    status: v.union(v.literal("pending"), v.literal("completed"), v.literal("failed")),
    error: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const scan = await ctx.db.query("scans").where("scanId", args.scanId);
    if (!scan) {
      throw new Error("Scan not found");
    }
    await ctx.db.update("scans", {
      status: args.status,
      error: args.error,
    });
  },
});

export const saveSubdomainResult = internalMutation({
  args: {
    scanId: v.number(),
    subdomain: v.string(),
    path: v.optional(v.string()),
    status: v.number(),
    risk: v.union(v.literal("High"), v.literal("Medium"), v.literal("Low")),
    ip: v.optional(v.string()),
    isp: v.optional(v.string()),
    ports: v.array(v.number()),
    services: v.array(v.string()),
    securityTrailsKey: v.optional(v.string()),
    shodanKey: v.optional(v.string()),
    apiKey: v.optional(v.string()),
    proto: v.optional(v.string()),
    controller: v.optional(v.object()),
  },
  handler: async (ctx, args) => {
    const scan = await ctx.db.query("scans").where("scanId", args.scanId);
    if (!scan) {
      throw new Error("Scan not found");
    }
    const subdomain = args.subdomain;
    const path = args.path;
    const status = args.status;
    const risk = args.risk;
    const ip = args.ip;
    const isp = args.isp;
    const ports = args.ports;
    const services = args.services;
    const securityTrailsKey = args.securityTrailsKey || process.env.SECURITYTRAILS_API_KEY;
    if (!securityTrailsKey) {
      await ctx.runMutation(internal.recon.updateScanStatus, {
        scanId,
        status: "failed",
        error: "Missing SecurityTrails API Key",
      });
      return;
    }

    // Step 1: Subdomains
    const domain = subdomain.split(".").slice(-2).join(".");
    const subdomains = await ctx.db.query("subdomains").where("domain", domain);
    const limitedSubdomains = subdomains.slice(0, 20);
    // Add the root domain too
    if (!limitedSubdomains.includes(domain)) limitedSubdomains.unshift(domain);

    // Step 2: Shodan
    let shodanData = null;
    if (args.shodanKey) {
      shodanData = await fetchShodanData(sub, args.shodanKey);
    }
    ip: shodanData?.ip,
    isp: shodanData?.isp,
    ports: shodanData?.ports || [],
    services: shodanData?.services || [],
    // Calculate Risk
    let risk: "High" | "Medium" | "Low" = "Low";
    if (exposures.length > 0) risk = "High";
    else if (shodanData && shodanData.ports.length > 0) risk = "Medium";
    const response = await fetch(
      `https://api.securitytrails.com/v1/domain/${domain}/subdomains`,
      {
        headers: {
          "Content-Type": "application/json",
          "X-Api-Key": securityTrailsKey,
        },
      }
    );
    const data = await response.json();
    return (data.subdomains as string[]).map((s) => `${s}.${domain}`);

    // Limit to first 20 for "Easy Version" / Demo purposes to avoid timeouts/rate limits
    const limitedSubdomains = subdomains.slice(0, 20);
    // Add the root domain too
    if (!limitedSubdomains.includes(domain)) limitedSubdomains.unshift(domain);

    // Step 2: Shodan
    let shodanData = null;
    if (shodanKey) {
      shodanData = await fetchShodanData(sub, shodanKey);
    }
    ip: shodanData?.ip,
    isp: shodanData?.isp,
    ports: shodanData?.ports || [],
    services: shodanData?.services || [],
    // Calculate Risk
    let risk: "High" | "Medium" | "Low" = "Low";
    if (exposures.length > 0) risk = "High";
    else if (shodanData && shodanData.ports.length > 0) risk = "Medium";
    const dnsRes = await fetch(
      `https://api.shodan.io/shodan/host/${ip}?key=${apiKey}`
    );
    const hostRes = await fetch(
      `https://api.shodan.io/shodan/host/${ip}?key=${apiKey}`
    );
    const dnsData = await dnsRes.json();
    const ip = dnsData[host];
    const hostData = await hostRes.json();
    return {
      ip,
      ports: hostData.ports || [],
      services: hostData.data?.map((d: any) => d.product || d.port.toString()) || [],
      isp: hostData.isp || "Unknown",
    };
    const res = await fetch(`${proto}${subdomain}${p.path}`, {
      method: "HEAD",
      signal: controller.signal,
    });
    if (res.status === 200) {

    } catch (error: any) {

  }
});

scans: defineTable({
  // ...
}).index("by_user", ["userId"]),

doc.text(`- ${sub.subdomain} (${sub.ip || "No IP"})`, 25, y);
exposures: v.array(
  v.object({
    path: v.string(),
    risk: v.union(v.literal("High"), v.literal("Medium"), v.literal("Low")),
    status: v.number(),
  })
),
exposures.push({
  path: p.path,
  risk: p.risk as "High" | "Medium" | "Low",
  status: 200,
});

export const performRecon = action({
  args: {
    scanId: v.number(),
    subdomain: v.string(),
    path: v.optional(v.string()),
    status: v.number(),
    risk: v.union(v.literal("High"), v.literal("Medium"), v.literal("Low")),
    ip: v.optional(v.string()),
    isp: v.optional(v.string()),
    ports: v.array(v.number()),
    services: v.array(v.string()),
    securityTrailsKey: v.optional(v.string()),
    shodanKey: v.optional(v.string()),
    apiKey: v.optional(v.string()),
    proto: v.optional(v.string()),
    controller: v.optional(v.object()),
  },
  handler: async (ctx, args) => {
    const { domain, scanId } = args;

    const scan = await ctx.db.query("scans").where("scanId", args.scanId);
    if (!scan) {
      throw new Error("Scan not found");
    }
    const subdomain = args.subdomain;
    const path = args.path;
    const status = args.status;
    const risk = args.risk;
    const ip = args.ip;
    const isp = args.isp;
    const ports = args.ports;
    const services = args.services;
    const securityTrailsKey = args.securityTrailsKey || process.env.SECURITYTRAILS_API_KEY;
    if (!securityTrailsKey) {
      await ctx.runMutation(internal.recon.updateScanStatus, {
        scanId,
        status: "failed",
        error: "Missing SecurityTrails API Key",
      });
      return;
    }

    // Step 1: Subdomains
    const domain = subdomain.split(".").slice(-2).join(".");
    const subdomains = await ctx.db.query("subdomains").where("domain", domain);
    const limitedSubdomains = subdomains.slice(0, 20);
    // Add the root domain too
    if (!limitedSubdomains.includes(domain)) limitedSubdomains.unshift(domain);

    // Step 2: Shodan
    let shodanData = null;
    if (args.shodanKey) {
      shodanData = await fetchShodanData(sub, args.shodanKey);
    }
    ip: shodanData?.ip,
    isp: shodanData?.isp,
    ports: shodanData?.ports || [],
    services: shodanData?.services || [],
    // Calculate Risk
    let risk: "High" | "Medium" | "Low" = "Low";
    if (exposures.length > 0) risk = "High";
    else if (shodanData && shodanData.ports.length > 0) risk = "Medium";
    const response = await fetch(
      `https://api.securitytrails.com/v1/domain/${domain}/subdomains`,
      {
        headers: {
          "Content-Type": "application/json",
          "X-Api-Key": securityTrailsKey,
        },
      }
    );
    const data = await response.json();
    return (data.subdomains as string[]).map((s) => `${s}.${domain}`);

    // Limit to first 20 for "Easy Version" / Demo purposes to avoid timeouts/rate limits
    const limitedSubdomains = subdomains.slice(0, 20);
    // Add the root domain too
    if (!limitedSubdomains.includes(domain)) limitedSubdomains.unshift(domain);

    // Step 2: Shodan
    let shodanData = null;
    if (shodanKey) {
      shodanData = await fetchShodanData(sub, shodanKey);
    }
    ip: shodanData?.ip,
    isp: shodanData?.isp,
    ports: shodanData?.ports || [],
    services: shodanData?.services || [],
    // Calculate Risk
    let risk: "High" | "Medium" | "Low" = "Low";
    if (exposures.length > 0) risk = "High";
    else if (shodanData && shodanData.ports.length > 0) risk = "Medium";
    const dnsRes = await fetch(
      `https://api.shodan.io/shodan/host/${ip}?key=${apiKey}`
    );
    const hostRes = await fetch(
      `https://api.shodan.io/shodan/host/${ip}?key=${apiKey}`
    );
    const dnsData = await dnsRes.json();
    const ip = dnsData[host];
    const hostData = await hostRes.json();
    return {
      ip,
      ports: hostData.ports || [],
      services: hostData.data?.map((d: any) => d.product || d.port.toString()) || [],
      isp: hostData.isp || "Unknown",
    };
    const res = await fetch(`${proto}${subdomain}${p.path}`, {
      method: "HEAD",
      signal: controller.signal,
    });
    if (res.status === 200) {

    } catch (error: any) {

  }
});

export const completeScan = internalMutation({
  args: {
    scanId: v.number(),
    riskScore: v.number(),
    subdomainCount: v.number(),
    highRiskCount: v.number(),
    mediumRiskCount: v.number(),
    lowRiskCount: v.number(),
  },
  handler: async (ctx, args) => {
    const scan = await ctx.db.query("scans").where("scanId", args.scanId);
    if (!scan) {
      throw new Error("Scan not found");
    }
    await ctx.db.update("scans", {
      status: "completed",
      riskScore: args.riskScore,
      subdomainCount: args.subdomainCount,
      highRiskCount: args.highRiskCount,
      mediumRiskCount: args.mediumRiskCount,
      lowRiskCount: args.lowRiskCount,
    });
  },
});